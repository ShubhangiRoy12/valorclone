<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ValorClone - Character Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f1923 0%, #1a2332 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 70, 85, 0.3);
        }

        #gameCanvas {
            border: 3px solid #ff4655;
            background: #1a1a2e;
            display: block;
        }

        #agentSelection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 25, 35, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff4655;
            box-shadow: 0 0 100px rgba(255, 70, 85, 0.5);
            z-index: 10;
        }

        #agentSelection h1 {
            color: #ff4655;
            text-align: center;
            font-size: 42px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255, 70, 85, 0.8);
        }

        .agent-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .agent-card {
            background: linear-gradient(135deg, #1a2332 0%, #0f1923 100%);
            border: 2px solid #444;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .agent-card:hover {
            transform: translateY(-10px);
            border-color: #ff4655;
            box-shadow: 0 10px 30px rgba(255, 70, 85, 0.5);
        }

        .agent-card.selected {
            border: 3px solid #ff4655;
            box-shadow: 0 0 30px rgba(255, 70, 85, 0.8);
        }

        .agent-icon {
            width: 100px;
            height: 120px;
            margin: 0 auto 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
        }

        .agent-name {
            color: white;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .agent-role {
            color: #888;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .agent-desc {
            color: #aaa;
            font-size: 12px;
        }

        #startButton {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #ff4655 0%, #ff1744 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        #startButton:hover {
            background: linear-gradient(135deg, #ff1744 0%, #ff4655 100%);
            box-shadow: 0 5px 20px rgba(255, 70, 85, 0.6);
            transform: scale(1.05);
        }

        #startButton:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }

        #abilities {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 5;
        }

        .ability-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4655;
            padding: 15px 25px;
            color: white;
            border-radius: 10px;
            font-weight: bold;
            text-align: center;
        }

        .ability-btn.ready {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .ability-btn.cooldown {
            border-color: #666;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="700"></canvas>
        
        <div id="agentSelection">
            <h1>üéØ SELECT YOUR AGENT</h1>
            <div class="agent-grid">
                <div class="agent-card" data-agent="phoenix">
                    <div class="agent-icon" style="background: linear-gradient(135deg, #ff6b35 0%, #ff4500 100%);">üî•</div>
                    <div class="agent-name" style="color: #ff6b35;">PHOENIX</div>
                    <div class="agent-role">Duelist</div>
                    <div class="agent-desc">Fire Agent<br>Heal & AOE Damage</div>
                </div>
                <div class="agent-card" data-agent="jett">
                    <div class="agent-icon" style="background: linear-gradient(135deg, #00d9ff 0%, #00bfff 100%);">üí®</div>
                    <div class="agent-name" style="color: #00d9ff;">JETT</div>
                    <div class="agent-role">Duelist</div>
                    <div class="agent-desc">Wind Agent<br>Speed & Mobility</div>
                </div>
                <div class="agent-card" data-agent="sage">
                    <div class="agent-icon" style="background: linear-gradient(135deg, #90ee90 0%, #32cd32 100%);">‚ú®</div>
                    <div class="agent-name" style="color: #90ee90;">SAGE</div>
                    <div class="agent-role">Sentinel</div>
                    <div class="agent-desc">Healer<br>Support & Defense</div>
                </div>
                <div class="agent-card" data-agent="viper">
                    <div class="agent-icon" style="background: linear-gradient(135deg, #228b22 0%, #006400 100%);">‚ò†Ô∏è</div>
                    <div class="agent-name" style="color: #32cd32;">VIPER</div>
                    <div class="agent-role">Controller</div>
                    <div class="agent-desc">Poison Agent<br>Zone Control</div>
                </div>
            </div>
            <button id="startButton" disabled>START MISSION</button>
        </div>

        <div id="hud" class="hidden">
            <div id="agentInfo"></div>
            <div id="healthBar"></div>
            <div id="scoreInfo"></div>
            <div id="roundInfo"></div>
        </div>

        <div id="abilities" class="hidden">
            <div class="ability-btn" id="abilityE">
                <div>E - ABILITY</div>
                <div id="abilityCooldown"></div>
            </div>
            <div class="ability-btn" id="abilityX">
                <div>X - ULTIMATE</div>
                <div id="ultCharge">0%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const agentSelection = document.getElementById('agentSelection');
        const hud = document.getElementById('hud');
        const abilities = document.getElementById('abilities');

        let gameState = 'selection';
        let selectedAgent = null;
        let player = null;
        let enemies = [];
        let bullets = [];
        let particles = [];
        let round = 1;
        let score = 0;
        let kills = 0;
        let keys = {};
        let mouseX = 0;
        let mouseY = 0;

        // Character Drawing Functions
        function drawCharacter(ctx, x, y, color, facing = 'right', isEnemy = false) {
            ctx.save();
            
            // Body proportions
            const bodyWidth = 14;
            const bodyHeight = 20;
            const headRadius = 7;
            const armLength = 12;
            const legLength = 15;
            const weaponLength = 18;
            
            // Animation offset for walking
            const walkCycle = Math.sin(Date.now() / 200) * 2;
            
            // Facing direction
            const dir = facing === 'right' ? 1 : -1;
            
            // Draw legs
            ctx.strokeStyle = isEnemy ? color : darkenColor(color, 40);
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(x - 3 * dir, y + 5);
            ctx.lineTo(x - 3 * dir + (walkCycle * dir), y + 5 + legLength);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(x + 3 * dir, y + 5);
            ctx.lineTo(x + 3 * dir + (-walkCycle * dir), y + 5 + legLength);
            ctx.stroke();
            
            // Draw body
            ctx.fillStyle = color;
            ctx.fillRect(x - bodyWidth/2, y - 10, bodyWidth, bodyHeight);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - bodyWidth/2, y - 10, bodyWidth, bodyHeight);
            
            // Draw arms
            ctx.strokeStyle = isEnemy ? color : darkenColor(color, 40);
            ctx.lineWidth = 4;
            
            // Back arm
            ctx.beginPath();
            ctx.moveTo(x - 5 * dir, y - 5);
            ctx.lineTo(x - 8 * dir, y + 3);
            ctx.stroke();
            
            // Front arm (holding weapon)
            ctx.beginPath();
            ctx.moveTo(x + 5 * dir, y - 5);
            ctx.lineTo(x + 12 * dir, y);
            ctx.stroke();
            
            // Draw weapon
            if (!isEnemy) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x + 12 * dir, y);
                ctx.lineTo(x + (12 + weaponLength) * dir, y - 2);
                ctx.stroke();
                
                // Weapon details
                ctx.fillStyle = '#555';
                ctx.fillRect(x + 12 * dir, y - 1, 4 * dir, 2);
                ctx.fillStyle = color;
                ctx.fillRect(x + (12 + weaponLength - 5) * dir, y - 3, 5 * dir, 4);
            }
            
            // Draw head
            ctx.fillStyle = isEnemy ? lightenColor(color, 20) : color;
            ctx.beginPath();
            ctx.arc(x, y - 17, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw face details
            if (!isEnemy) {
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - 2 * dir, y - 18, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 2 * dir, y - 18, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Visor/goggles effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y - 17, headRadius - 1, 0, Math.PI);
                ctx.stroke();
            } else {
                // Enemy eyes (red)
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(x - 2 * dir, y - 18, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 2 * dir, y - 18, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw tactical gear/vest
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x - bodyWidth/3, y - 8, bodyWidth * 0.66, bodyHeight * 0.7);
            
            ctx.restore();
        }

        function drawEnemy(ctx, x, y, color) {
            ctx.save();
            
            const bodyWidth = 12;
            const bodyHeight = 18;
            const headRadius = 6;
            const legLength = 14;
            
            const walkCycle = Math.sin(Date.now() / 180) * 2;
            
            // Draw legs
            ctx.strokeStyle = darkenColor(color, 50);
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x - 3, y + 4);
            ctx.lineTo(x - 3 + walkCycle, y + 4 + legLength);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x + 3, y + 4);
            ctx.lineTo(x + 3 - walkCycle, y + 4 + legLength);
            ctx.stroke();
            
            // Body
            ctx.fillStyle = color;
            ctx.fillRect(x - bodyWidth/2, y - 9, bodyWidth, bodyHeight);
            
            // Arms
            ctx.strokeStyle = darkenColor(color, 50);
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 4);
            ctx.lineTo(x - 10, y + 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x + 5, y - 4);
            ctx.lineTo(x + 10, y + 2);
            ctx.stroke();
            
            // Head
            ctx.fillStyle = lightenColor(color, 30);
            ctx.beginPath();
            ctx.arc(x, y - 15, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Angry eyes
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(x - 3, y - 16, 2, 2);
            ctx.fillRect(x + 1, y - 16, 2, 2);
            
            // Evil mouth
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x, y - 13, 2, 0, Math.PI);
            ctx.stroke();
            
            ctx.restore();
        }

        // Color utility functions
        function darkenColor(color, amount) {
            const rgb = hexToRgb(color);
            return `rgb(${Math.max(0, rgb.r - amount)}, ${Math.max(0, rgb.g - amount)}, ${Math.max(0, rgb.b - amount)})`;
        }

        function lightenColor(color, amount) {
            const rgb = hexToRgb(color);
            return `rgb(${Math.min(255, rgb.r + amount)}, ${Math.min(255, rgb.g + amount)}, ${Math.min(255, rgb.b + amount)})`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        // Agent Selection
        document.querySelectorAll('.agent-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.agent-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedAgent = card.dataset.agent;
                document.getElementById('startButton').disabled = false;
            });
        });

        document.getElementById('startButton').addEventListener('click', () => {
            if (selectedAgent) {
                startGame();
            }
        });

        // Agent Configurations
        const agents = {
            phoenix: {
                name: 'Phoenix',
                color: '#ff6b35',
                abilityColor: '#ff4500',
                abilityCooldown: 8000,
                abilityEffect: (player) => {
                    player.health = Math.min(100, player.health + 30);
                    createParticles(player.x, player.y, '#ff6b35', 30);
                },
                ultimateEffect: (player, enemies) => {
                    enemies.forEach(enemy => {
                        const dist = distance(player, enemy);
                        if (dist < 300) {
                            enemy.health -= 40;
                            createParticles(enemy.x, enemy.y, '#ff6b35', 20);
                        }
                    });
                    player.health = Math.min(100, player.health + 50);
                }
            },
            jett: {
                name: 'Jett',
                color: '#00d9ff',
                abilityColor: '#00bfff',
                abilityCooldown: 6000,
                abilityEffect: (player) => {
                    player.dashActive = true;
                    player.speed = 10;
                    setTimeout(() => {
                        player.speed = 5;
                        player.dashActive = false;
                    }, 500);
                    createParticles(player.x, player.y, '#00d9ff', 25);
                },
                ultimateEffect: (player) => {
                    player.damageMultiplier = 2;
                    setTimeout(() => {
                        player.damageMultiplier = 1;
                    }, 5000);
                    createParticles(player.x, player.y, '#00d9ff', 40);
                }
            },
            sage: {
                name: 'Sage',
                color: '#90ee90',
                abilityColor: '#32cd32',
                abilityCooldown: 10000,
                abilityEffect: (player) => {
                    player.health = Math.min(100, player.health + 60);
                    createParticles(player.x, player.y, '#90ee90', 30);
                },
                ultimateEffect: (player) => {
                    player.health = 100;
                    player.shield = 50;
                    createParticles(player.x, player.y, '#90ee90', 50);
                }
            },
            viper: {
                name: 'Viper',
                color: '#32cd32',
                abilityColor: '#228b22',
                abilityCooldown: 7000,
                abilityEffect: (player) => {
                    player.poisonActive = true;
                    setTimeout(() => {
                        player.poisonActive = false;
                    }, 3000);
                    createParticles(player.x, player.y, '#228b22', 30);
                },
                ultimateEffect: (player, enemies) => {
                    enemies.forEach(enemy => {
                        const dist = distance(player, enemy);
                        if (dist < 400) {
                            enemy.health -= 50;
                            createParticles(enemy.x, enemy.y, '#228b22', 25);
                        }
                    });
                }
            }
        };

        // Player Class
        class Player {
            constructor(agent) {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.speed = 5;
                this.health = 100;
                this.maxHealth = 100;
                this.shield = 0;
                this.agent = agents[agent];
                this.lastShot = 0;
                this.shootCooldown = 300;
                this.abilityReady = true;
                this.abilityLastUsed = 0;
                this.ultCharge = 0;
                this.damageMultiplier = 1;
                this.poisonActive = false;
                this.facing = 'right';
                this.lastX = this.x;
            }

            draw() {
                // Update facing direction based on movement
                if (this.x > this.lastX) this.facing = 'right';
                if (this.x < this.lastX) this.facing = 'left';
                this.lastX = this.x;

                // Draw poison cloud effect
                if (this.poisonActive) {
                    ctx.fillStyle = 'rgba(34, 139, 34, 0.15)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 200, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw character
                drawCharacter(ctx, this.x, this.y, this.agent.color, this.facing, false);

                // Health bar above character
                const barWidth = 40;
                const barHeight = 5;
                const barY = this.y - 40;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth * (this.health / this.maxHealth), barHeight);

                // Shield bar
                if (this.shield > 0) {
                    ctx.fillStyle = 'cyan';
                    ctx.fillRect(this.x - barWidth/2, barY - 7, barWidth * (this.shield / 50), 4);
                }
            }

            move() {
                if (keys['w'] && this.y > 40) this.y -= this.speed;
                if (keys['s'] && this.y < canvas.height - 40) this.y += this.speed;
                if (keys['a'] && this.x > 40) this.x -= this.speed;
                if (keys['d'] && this.x < canvas.width - 40) this.x += this.speed;
            }

            shoot(targetX, targetY) {
                const now = Date.now();
                if (now - this.lastShot > this.shootCooldown) {
                    this.lastShot = now;
                    bullets.push(new Bullet(this.x, this.y, targetX, targetY, this.damageMultiplier));
                }
            }

            useAbility() {
                const now = Date.now();
                if (now - this.abilityLastUsed > this.agent.abilityCooldown) {
                    this.abilityLastUsed = now;
                    this.abilityReady = false;
                    this.agent.abilityEffect(this);
                    setTimeout(() => {
                        this.abilityReady = true;
                    }, this.agent.abilityCooldown);
                }
            }

            useUltimate() {
                if (this.ultCharge >= 100) {
                    this.ultCharge = 0;
                    this.agent.ultimateEffect(this, enemies);
                }
            }

            update() {
                this.move();
                
                if (this.poisonActive) {
                    enemies.forEach(enemy => {
                        if (distance(this, enemy) < 200) {
                            if (Math.random() < 0.05) {
                                enemy.health -= 2;
                            }
                        }
                    });
                }

                if (this.shield > 0) {
                    this.shield -= 0.1;
                    if (this.shield < 0) this.shield = 0;
                }
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x, y, targetX, targetY, damageMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.radius = 4;
                this.speed = 15;
                this.damage = 25 * damageMultiplier;
                
                const angle = Math.atan2(targetY - y, targetX - x);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }

            draw() {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Bullet trail
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x - this.vx * 0.3, this.y - this.vy * 0.3, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            isOffScreen() {
                return this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height;
            }
        }

        // Enemy Class
        class Enemy {
            constructor(type = 'normal') {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) {
                    this.x = Math.random() * canvas.width;
                    this.y = -50;
                } else if (side === 1) {
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height + 50;
                } else if (side === 2) {
                    this.x = -50;
                    this.y = Math.random() * canvas.height;
                } else {
                    this.x = canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                }

                this.type = type;
                this.lastX = this.x;
                this.facing = 'right';
                
                if (type === 'tank') {
                    this.speed = 1;
                    this.health = 100;
                    this.maxHealth = 100;
                    this.color = '#8b00ff';
                    this.damage = 30;
                } else if (type === 'fast') {
                    this.speed = 4;
                    this.health = 30;
                    this.maxHealth = 30;
                    this.color = '#ff8c00';
                    this.damage = 15;
                } else {
                    this.speed = 2;
                    this.health = 50;
                    this.maxHealth = 50;
                    this.color = '#ff3333';
                    this.damage = 20;
                }

                this.lastAttack = 0;
                this.attackCooldown = 1000;
                this.poisonDamageTimer = 0;
            }

            draw() {
                // Update facing
                if (this.x > this.lastX) this.facing = 'right';
                if (this.x < this.lastX) this.facing = 'left';
                this.lastX = this.x;

                drawEnemy(ctx, this.x, this.y, this.color);

                // Health bar
                const barWidth = 35;
                const barHeight = 4;
                const barY = this.y - 35;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'darkred';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth * (this.health / this.maxHealth), barHeight);
            }

            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                if (distance(this, player) < 50) {
                    const now = Date.now();
                    if (now - this.lastAttack > this.attackCooldown) {
                        this.lastAttack = now;
                        if (player.shield > 0) {
                            player.shield -= this.damage;
                            if (player.shield < 0) {
                                player.health += player.shield;
                                player.shield = 0;
                            }
                        } else {
                            player.health -= this.damage;
                        }
                    }
                }
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.color = color;
                this.life = 40;
                this.size = Math.random() * 4 + 2;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 40;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
                this.size = Math.max(0, this.size - 0.1);
            }
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function drawBackground() {
            const grassGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grassGradient.addColorStop(0, '#3a5a40');
            grassGradient.addColorStop(0.5, '#588157');
            grassGradient.addColorStop(1, '#3a5a40');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(42, 70, 45, 0.3)';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillRect(x, y, 3, 3);
            }

            const pathColor = '#5a5a5a';
            const pathY = canvas.height / 2 - 75;
            ctx.fillStyle = pathColor;
            ctx.fillRect(0, pathY, canvas.width, 150);

            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 4;
            ctx.setLineDash([30, 20]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);

            const vPath1 = canvas.width / 3;
            const vPath2 = (canvas.width / 3) * 2;
            ctx.fillStyle = pathColor;
            ctx.fillRect(vPath1 - 50, 0, 100, canvas.height);
            ctx.fillRect(vPath2 - 50, 0, 100, canvas.height);

            drawTacticalMarkers();
        }

        function drawTacticalMarkers() {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 70, 85, 0.3)';
            ctx.beginPath();
            ctx.arc(200, 150, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff4655';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#ff4655';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('A', 200, 165);
            
            ctx.fillStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(1000, 550, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#00d9ff';
            ctx.fillText('B', 1000, 565);
            ctx.restore();
        }

        let lastSpawn = 0;
        const spawnDelay = 2000;
        let maxEnemies = 5;
        let enemiesKilledThisRound = 0;
        let enemiesToKill = 10;

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastSpawn > spawnDelay && enemies.length < maxEnemies && enemiesKilledThisRound < enemiesToKill) {
                lastSpawn = now;
                let type = 'normal';
                const rand = Math.random();
                if (round >= 3 && rand < 0.3) type = 'tank';
                else if (round >= 2 && rand < 0.6) type = 'fast';
                enemies.push(new Enemy(type));
            }
        }

        function startGame() {
            agentSelection.classList.add('hidden');
            hud.classList.remove('hidden');
            abilities.classList.remove('hidden');
            gameState = 'playing';
            player = new Player(selectedAgent);
            gameLoop();
        }

        function updateHUD() {
            document.getElementById('agentInfo').innerHTML = `
                <div style="font-size: 24px; color: ${player.agent.color}; font-weight: bold;">
                    ${player.agent.name}
                </div>
            `;
            document.getElementById('healthBar').innerHTML = `
                <div style="margin-top: 10px;">
                    <div style="font-size: 16px;">HP: ${Math.floor(player.health)}/${player.maxHealth}</div>
                    ${player.shield > 0 ? `<div style="font-size: 14px; color: cyan;">Shield: ${Math.floor(player.shield)}</div>` : ''}
                </div>
            `;
            document.getElementById('scoreInfo').innerHTML = `
                <div style="margin-top: 10px;">
                    <div>Score: ${score}</div>
                    <div>Kills: ${kills}</div>
                </div>
            `;
            document.getElementById('roundInfo').innerHTML = `
                <div style="margin-top: 10px; font-size: 22px; color: #ff4655;">
                    ROUND ${round}
                </div>
                <div>Enemies Left: ${enemiesToKill - enemiesKilledThisRound}</div>
            `;

            const abilityE = document.getElementById('abilityE');
            const now = Date.now();
            const abilityCooldownRemaining = Math.max(0, player.agent.abilityCooldown - (now - player.abilityLastUsed));
            
            if (abilityCooldownRemaining === 0) {
                abilityE.classList.remove('cooldown');
                abilityE.classList.add('ready');
                document.getElementById('abilityCooldown').textContent = 'READY';
            } else {
                abilityE.classList.remove('ready');
                abilityE.classList.add('cooldown');
                document.getElementById('abilityCooldown').textContent = `${(abilityCooldownRemaining / 1000).toFixed(1)}s`;
            }

            const abilityX = document.getElementById('abilityX');
            document.getElementById('ultCharge').textContent = `${Math.floor(player.ultCharge)}%`;
            if (player.ultCharge >= 100) {
                abilityX.classList.add('ready');
            } else {
                abilityX.classList.remove('ready');
            }
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            drawBackground();

            player.update();
            player.draw();

            bullets.forEach((bullet, index) => {
                bullet.update();
                bullet.draw();
                
                if (bullet.isOffScreen()) {
                    bullets.splice(index, 1);
                } else {
                    enemies.forEach((enemy, enemyIndex) => {
                        if (distance(bullet, enemy) < 25) {
                            enemy.health -= bullet.damage;
                            bullets.splice(index, 1);
                            createParticles(enemy.x, enemy.y, 'red', 5);
                            
                            if (enemy.health <= 0) {
                                enemies.splice(enemyIndex, 1);
                                score += 100;
                                kills++;
                                enemiesKilledThisRound++;
                                player.ultCharge = Math.min(100, player.ultCharge + 10);
                                createParticles(enemy.x, enemy.y, enemy.color, 15);
                            }
                        }
                    });
                }
            });

            spawnEnemy();
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            particles.forEach((particle, index) => {
                particle.update();
                particle.draw();
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            if (enemiesKilledThisRound >= enemiesToKill && enemies.length === 0) {
                if (round >= 5) {
                    gameState = 'victory';
                    showEndScreen('VICTORY!', 'lime');
                    return;
                } else {
                    nextRound();
                }
            }

            if (player.health <= 0) {
                gameState = 'gameOver';
                showEndScreen('GAME OVER', 'red');
                return;
            }

            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        function nextRound() {
            round++;
            enemiesKilledThisRound = 0;
            enemiesToKill += 5;
            player.health = Math.min(100, player.health + 50);
            enemies = [];
            bullets = [];
            if (round % 2 === 0) maxEnemies++;
        }

        function showEndScreen(message, color) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = color;
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText(`Total Kills: ${kills}`, canvas.width / 2, canvas.height / 2 + 60);
            ctx.fillText(`${player.agent.name} - Round ${round}`, canvas.width / 2, canvas.height / 2 + 100);
            
            ctx.font = '20px Arial';
            ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 150);
        }

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key.toLowerCase() === 'e' && gameState === 'playing') {
                player.useAbility();
            }
            if (e.key.toLowerCase() === 'x' && gameState === 'playing') {
                player.useUltimate();
            }
            if (e.key.toLowerCase() === 'r' && (gameState === 'gameOver' || gameState === 'victory')) {
                location.reload();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (gameState === 'playing') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                player.shoot(x, y);
            }
        });
    </script>
</body>
</html>
